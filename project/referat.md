# Криптиране, хеширане и посоляване

## Неща за довършване
- допълване на темата за криптиране
- добавяне на тема за хеширане
- посоляване и подлютяване.
- спазване на добрите практики в CSS
- спазване на добрите практики в JS
- групиране на елементите в логически свързани контейнери
- оптимизиране на JS кода
- прилагане на по-хубав CSS - може би.


## Въведение 

Всеки човек, използващ интернет, се е сблъсквал с процесите по криптиране и хеширане на информация, но може би единствено изучените програмисти знаят какви процеси стоят зад тези сложни термини. 

Криптирането е основен процес при сигурния трансфер на данни, използван в комуникацията между повечето модерни устройства. Предаваната информация се криптира, така че единствено желаният получател да може да разтълкува съдържанието й. Така зловредни опити за разчитане на информацията при процеса на трансфер биват напрактика безполезни. Пример за това би било при плащане с банкова карта, външно лице да се опита да извлече банковата ни информация, проследявайки криптираните данни от транзакцията.

При хеширането основният проблем, който се разрешава, е проверката за интегритет (цялост) на дадени данни. Стойността получена при хеширането на дадени данни е уникална, като всяка малка промяна в данните води до напълно различна хеш стойност. Освен това хеширането не е обратим процес за разлика от криптирането т.е. при наличие на хеш стойността не можем да възстановим първоначалния вид на данните. Така например безопасно могат да се съхраняват пароли чрез тяхната уникална хеш стойност без притеснения, че хакер получил достъп до базата, ще получи достъп и до акаунтите на потребителите

Но какво ще стане, ако хакерът в горния пример забележи, че в базата с хешираните пароли има еднакви стойности? Това би подсказало на хакера, че съответните потребители използват често срещани пароли. Всеки уважаващ себе си хакер би успял да разбие тези лесни пароли за отрицателно време. За да се предотврати този проблем, повечето модерни апликации използват техниката посоляване. Посоляването е процесът по прибавяне на допълнителна последователност от символи към потребителската парола преди процеса на хеширане. Така двама потребители с еднаква парола, ще имат различни хеш стойности в базата данни, което значително усложнява работата на злонамерените хакери.

Нека разгледаме по-подробно гореописаните понятия.

## Криптиране

Криптирането не е процес, който навлиза в употреба с появата на компютрите. Исторически данни показват, че още древните египтяни са използвали система за промяна текстове си, така че само избрани лица от аристокрацията да разберат значението им.

### Шифърът на Цезар

Един от най-известните ранни шифри е този използван от римския император Юлий Цезар. Цезар е използвал примитивна версия на "Shift" шифър, за да води скрита от враговете си кореспонденция. Шифърът на Цезар взема дадено съобщение и заменя всяка самостоятелна буква в него с буквата на 3 позиции напред в азбуката.

Например в криптирано съобщение думата "ВОЙНА" ще бъде заменена с "ЕСМРГ", тъй като на буквата "В" отговаря буквата "Е", на "О" - "С" и т.н. Когато получателят види криптираното съобщение той трябва да използва обратния процес декриптиране, за да разбере съдържанието му. Това изисква предварителна "уговорка" между двете лица, тоест криптиращия участник трябва да сподели метода на декриптиране на своя събеседник преди започване на криптираната комуникация.

В нашия пример съобщението "ЕСМРГ" ще бъде декодирано, като за всяка негова буква бъде заменена с тази на 3 позиция преди нея в азбуката. Това е обратният процес на операцията по кодиране. С по-математически термини, ако представим буквите от азбуката чрез числата от 0 до 29 (A е 0, Б е 1, ..., Я е 29), то функцията на кодиране е "Fn(x) = (x + n) mod 30", където n е броят измествания надясно (при Цезаровия шифър n = 3). Функцията за Декориране "Gn(x) = (x - n) mod 30".

### Разбиване на криптиращ алгоритъм
Ефективността на един шифър или алгоритъм за криптиране се определя чрез времето нужно за разгадаването му - разбиването на ключа. Алгоритъмът на Цезар, колкото и примитивен да изглежда, е бил разгадан едва след 9 века от арабски учен. Въпреки това, ако е известен метода за изместване на азбуката с дадено число, то са нужни 30 на броя опита, за да се разгадае ключа, равен на 3. 

Съществуват различни вариации на шифъра на Цезар, които се опитват да увеличат сложността на алгоритъма. Ако се използва индивидуално подреждане, такова че всяка буква отговаря на произволна друга възможните комбинации за ключ стават 26!. Това е число с 26 нули, което би довело читателя до мисълта, че този шифър би бил неразбиваем. Това ще е вярно, ако се използва наивен "brute force" метод за решаването на проблема.

При анализирането на даден криптиращ алгоритъм повече на брой ключове, не винаги значи по-сигурен алгоритъм. Съществуват техники като семантичния анализ, които лесно разбиват семейството от шифри, произлизащи от Цезаровия. Семантичният анализ проверява колко често се среща всяка буква в шифрованото съобщение. Това носи изключително много информация за възможните ключове, тъй като най-срещаните букви в езика, ще отговарят на най-срещаните букви в криптираното съобщение.

Например петте най-често срещаните букви в българския език са "А", "И", "О", "Е" и "Н". Нека си представим как сме шпиони, които са се добрали до кодираното съобщение "ЧА КУЕ ЖЧРЮДЗ ЖЧ ИЮЛЖЧЬЮКЮЛ ОБДЦЬЖЧ ЧЙЕБЦ Б ИУЛМЩЧЕ ГУЕ ЩЧК" и искаме да го разгадаем. Ако анализираме броя срещания на всяка буква ще забележим, че най-често срещана в съобщението е буквата "Ч", следвана от "Е", "Ж", "Ю". Много по-вероятно е кодираната буква "Ч" да отговаря на "А" в реалното съобщение, отколкото на буквата "Щ" например. 

Съобщението е: "АЗ СЪМ НАЧЕЛО НА ПЕТНАДЕСЕТ ХИЛЯДНА АРМИЯ И ПЪТУВАМ КЪМ ВАС"

## Криптиращи ключове
Друг примерен вариант е Шифърът на Виженер. Нека си представим ключа на обикновения шифър на Цезар, като една буква - примерно ключ "Г". Това ще означава, че местим всяка буква от оригиналното съобщение с 3 позиции напред, тъй като буквата "Г" е третата буква в азбуката, ако започнем броенето от 0. Горният вариант на шифър, където всяка буква сочи към друга буква, има ключ с дължина 30 - на всяка буква от азбуката показваме с колко да се измести чрез друга буква от азбуката. Тогава Шифърът на Виженер може да има ключ с произволна дължина.

Например ключа "ГБК" означава, че първата буква в нашето съобщение ще бъде преместена с 3 позиции напред, тъй като "Г" е третата буква от азбуката, като започнем от 0. Следващата буква в нашето съобщение ще бъде криптирана чрез изместването й на 1 позиция напред в азбуката ("Б" = 1). Третата буква в нашето съобщение ще бъде изместена с 10 позиции напред ("К" = 10). След това повтаряме процеса по криптиране, като започваме от четвъртата буква на съобщението и първия символ на ключа.

Нека криптираме съобщението "ЗАПОЧВАМЕ ВОЙНА" с ключа "ГБК". Това се получава, като заместим "З" с буквата 3 позиции напред - "К", поради ключа "Г", после "А" с "Б" заради "Б", "П" с "Щ" заради "К", "О" със "С" заради "Г" и т.н. Крайният резултат от криптиращия алгоритъм е низът "КБЩСШМГНП ЕПУРБ".

Шифърът на Виженер на пръв поглед се справя с проблема с често повтарящите се букви. В зависимост от дължината на ключа един път буквата "А" може да се превърне в "Б", друг път в "С". Така семантичния анализ изглежда няма да помогне при анализиране на криптиращия алгоритъм. Това  обаче не е напълно вярно. Съществуват множество алгоритми, чрез които може да се определи дължината на ключа. Когато веднъж знаем дължината на ключа, разбиването на шифъра на Виженер се свежда до това да разбием няколко на брой последователни Цезарови шифъра. Като дори тогава можем да използваме семантично изследване във всеки един отделен шифър.

## Битове

Модерните ключове представляват поредица от нули и единици обикновено с дължина 128 или 256 символа. Известни са още като 128-битови или 256-битови ключове. Възможните ключове с дължина 128 бита са 2 на степен 128 или число с 38 нули. Това е така, защото на всеки бит избираме дали да е 0 или 1. Имаме 128 избора или 2*2*2...*2 = 2^128 възможни комбинации. Ако отгатвате по 1 милиард възможни ключа в секунда и сте започнали при самото създаването на Вселената, няма все още да сте минали 1 процент от всички възможни комбинации. 

Цялата информация, която се предава в интернет пространството може да се представи като поредица от нули и единици. За простота ще използваме ASCII таблицата. Тя показва как можем да представим текст чрез поредица от числа, като заменим всеки символ с дадено число. Например малката латинска буква 'a' се представя чрез числото 97, малкото 'b' с 98, малкото 'z' с 122, голямото 'А' със 65, 'B с 66, 'Z' с 90. Всъщност се извършва вид кодиране - всеки символ се кодира със зададено в таблицата число. Имаме кодиране на компютърната азбука, състояща се от 256 символа в числата от 0 до 255. Така думата 'ball' ще бъде преведена до числата 98, 97, 108, 108. Какво общо имат тези числа с битовете?

За да отговорим на този въпрос, трябва да разбираме как се преминава от десетична бройна система в двоична бройна система. Записът на числото 108 в десетична бройна система показва, че имаме 1 стотица, 0 десетици и 8 единици. Можем да запишем числото 108 като 100 * 1 + 10 * 0 + 1 * 8. Ако заменим със степени на десетката, получаваме (10^2) * 1 + (10^1) * 0 + (10^0) * 8. Така числото 101 в двоична бройна система означава, че имаме (2^2) * 1 + (2^1) * 0 + (2^0) * 1 = 4 * 1 + 2 * 0 + 1 * 1 = 5. Така всеки бит показва дали ще включим съответна степен на двойката при получаване на финалното число или не. Числото 101 показва - включваме 4, не включваме 2, включваме 1, получаваме 5 след сумиране. Същото е и при числото 108 в десетична бройна система - нулата показва, че нямаме десетици, но имаме 1 стотица и 8 единици. Числото 108 в двоична бройна система е 01101100 или (2^7) * 0 + (2^6) * 1 + (2^5) * 1 + (2^4) * 0 + (2^3) * 1 + (2^2) * 1 + (2^1) * 0 + (2^0) * 0 = 128 * 0 + 64 * 1 + 32 * 1 + 16 * 0 + 8 * 1 + 4 * 1 + 2* 0 + 1 * 0 = 108.

Вече знаем, че думата 'ball' се кодира до последователните числа "98, 97, 108, 108", които в двоична бройна система се изписват така: 01100010, 01100001, 01101100, 01101100. Първата нула е използвана за уеднаквяване на дължината на символите - така знаем, че първите 8 бита са 1 символ, следващите 8 бита са втория символ и т.н. Сега спокойно можем да представим низа "ball" като последователността от 32 бита "01100010011000010110110001101100". Ще използваме  4-битовия ключ "1100" за кодиране на горната последователност. Самият ключ не ни е достатъчен да кодираме съобщението - трябва ни функция на кодирането.

Ще използваме операцията "побитово или", изписвана още "|". Функцията приема два бита и връща резултат 0, ако и двата бита с 0 или 1 във всички останали случаи. Започваме да криптираме всички групички от 4 бита в първоначалното съобщение като използваме ключа и дефинираната функция. От първата група 0110 | 1100 получаваме 1110 с финален резултат "11101110111011011110110011101100". След това можем да превърнем криптираната поредица от битове в четири числа в десетична бройна система, които пък да превърнем в последователност от символи чрез ASCII таблицата.

Така криптирано съобщение с 4-битовия ни ключ изглежда по този начин: "îíìì"

## Осъществяване на комуникацията

Симетричното криптиране използва един ключ за криптиране и декриптиране на данните. Процесът по криптиране на данните със споделен ключ не изисква големи количества изчислителна мощ. Освен това създаването на такива ключове е сравнително бърза операция. Основният проблем свързан със симетричното криптиране е споделянето на ключа. За да си комуникират двете страни, те трябва предварително да знаят ключа. В миналото са се извършвали операции по дискретно доставяне на физически ключове до важните организации в света, което е било изключително скъп процес, но и опасен. Бъде ли прихванат ключа, цялата комуникация може да бъде подслушвана. Така се налага ключа, изпращан до човека, с който искаме да комуникираме, също да бъде криптиран с друг алгоритъм. Но какъв ще е ключа за новия криптиращ алгоритъм и как ще бъде предварително споделен?

В решаване на този проблем през 70-те години на 20-ти век се разработва асиметричното криптиране. То използва два ключа - публичен и частен. Публичният ключ е известен на всички страни в комуникацията и се използва за криптирането да данните. Изпратените криптирани данни обаче не могат да се декодират с друго освен частния ключ. Частният ключ се знае само от страната получател. Така всеки друг прихванал данните не може да разбере техния смисъл.

Нека разгледаме примера как Ани и Борко ще осъществят поверителна комуникация чрез асиметрично криптиране. Всеки участник в комуникацията притежава частен ключ. Частният ключ е разработен така че само той да декодира данните от друг ключ - публичния. Ани споделя своя разработен публичен ключ със света. Борко желае да изпрати съобщение да Ани. Той вижда споделения публичен ключ на Ани, използва го да криптира своето съобщение и го изпраща на Ани. Ани получава криптираното съобщение. Само тя знае какъв е нейния частен ключ - само той може да декодира получените съобщения. Ани използва своя таен ключ и разбира съобщението на Борко. Така, ако някой трети човек - Иван, проследи съобщението и има достъп до публичния ключ на Ани, не може да разбере информацията, която Борко ѝ е пратил.

От по-научна гледна точка асиметричното криптиране използва така наречените "функции капан". Ако "f" е функция капан и "y=f(x)" е лесно за пресмятане, то "x=f^-1(y)" изисква огромно количество изчислителна мощ за пресмятане, освен ако не се знае допълнително, помощно число - "k", с което пресмятането на "x=f^-1(y, k)" е тривиално. Така криптирането на дадено съобщение "x" с публичния ключ, пресмятането на "y", е бърза операция , но декриптирането - пресмятането на първоначалното съобщение "x" чрез криптираното "y" е почти невъзможно. Но ако човек знае частния ключ - "k", възстановяването на "x" е мигновен процес.

Примерна "функция капан" е процесът по умножаване на две прости числа - "p" и "q". Лесно можем да изчислим колко е тяхното произведение - лесно се смята "y=f(p, q)". Но обратният въпрос - от дадено "y" да кажем кои две прости числа са били умножени за получаването на "y" отнема огромно количество време. Например, трудно ще определим "p" и "q", ако е дадено "y = 6895601". Трябва да минем през всяко едно просто число, докато не получим един от делители на "y". Но ако получим информация, че "p = 1931", то веднага можем да кажем чрез деление колко е другото просто число "q". Разбира се, модерните компютри могат бързо да провървят всички прости числа и да намерят делителите на 6895601, но с увеличаването на числото "y", тази задача става непосилна за тях.

Асиметричното криптиране се извършва по-бавно, с повече ресурси отколкото симетричното криптиране. При обмяната на големи количества данни е подходящо да се използва споделен ключ, но как поверително да обменим този ключ? В практиката се използва хибридна версия между двете криптирания. Идеята е споделения ключ да бъде "договорен" чрез асиметрично криптиране, като се използват частните и публични ключове на двете страни в комуникацията. След като споделеният ключ е предаден тайно, може да се премине към синхронно криптиране.


## Хеширане

За разлика от криптирането, хеширането е необратим процес...

## Посоляване


## Източници:
- https://en.m.wikipedia.org/wiki/Pepper_(cryptography)
- https://www.php.net/manual/en/function.password-hash.php 
- https://www.thesslstore.com/blog/difference-encryption-hashing-salting/ 
- https://www.comparitech.com/blog/information-security/encryption-hashing-salting/
- https://cybernews.com/security/hashing-vs-encryption/
- https://en.wikipedia.org/wiki/Caesar_cipher
- https://www.csfieldguide.org.nz/en/chapters/coding-encryption/substitution-ciphers/
- http://simia.net/letters/
- https://cloud.google.com/learn/what-is-encryption
- https://www.practicalnetworking.net/series/cryptography/using-asymmetric-keys/
- https://en.wikipedia.org/wiki/Trapdoor_function

"ТС-ЗСДУИ ЦЙГФИР НУГМ, СХНСОНСХС ЦЙГФ ДИК НУГМ."
~ЩИКГУ

